# ROADMAP: Исправление статичности рендеринга стен

## ПРОБЛЕМА
Стены изменяют свой визуальный размер при зуме. При приближении/отдалении геометрия стен масштабируется вместе с камерой, что выглядит некорректно. Нужна система как в AutoCAD, где геометрия масштабируется, но визуально остается стабильной.

## КОРНЕВАЯ ПРИЧИНА
В `WallRenderer::DrawWall()` используется неправильный подход:
1. Точки стен преобразуются в экранные координаты через `camera.WorldToScreen()`
2. Затем к экранным координатам добавляется фиксированный offset в пикселях (m_wallHalfWidthPx = 6px)
3. Это создаёт визуальный артефакт: при зуме геометрия стены масштабируется, но её визуальная "толщина" на экране остается 12 пикселей

**Правильный подход:**
- Стена должна иметь реальную толщину в мировых координатах (например, 150мм)
- Углы геометрии стены вычисляются в мировых координатах
- Только затем углы преобразуются в экранные координаты
- Толщина обводки (stroke) остается в пикселях - это корректно

---

## ЭТАПЫ РЕАЛИЗАЦИИ

### ? ЭТАП 1: Анализ текущей архитектуры
**Цель:** Понять все места, где рендерятся стены и используется текущая система

**Задачи:**
- [x] 1.1. Изучить WallRenderer.h - текущая система рендеринга
- [x] 1.2. Изучить Camera.h - система координат и трансформаций
- [x] 1.3. Изучить Models.h - класс Wall и его свойства
- [x] 1.4. Проверить использование GetCornerPoints() в Wall

**Критерии завершения:**
- ? Понятна текущая архитектура
- ? Найдены все места рендеринга стен
- ? Понятен класс Wall и его методы
- ? Выявлена корневая причина проблемы

**Статус:** ? ЗАВЕРШЕНО

---

### ? ЭТАП 2: Рефакторинг WallRenderer для использования мировых координат
**Цель:** Переписать метод DrawWall для правильного преобразования координат

**Задачи:**
- [x] 2.1. Изменить DrawWall для использования m_thickness из Wall (мировые координаты)
- [x] 2.2. Вычислять углы геометрии стены в мировых координатах
- [x] 2.3. Преобразовывать все 4 угла стены в экранные координаты через WorldToScreen
- [x] 2.4. Удалить m_wallHalfWidthPx (больше не нужен)
- [x] 2.5. Сохранить m_wallStrokeWidthPx и m_selectedStrokeWidthPx для обводки
- [x] 2.6. Уменьшить толщину обводки с 4.0f до 2.0f для более четкого отображения

**Детальная реализация:**
```cpp
// БЫЛО (неправильно):
ScreenPoint start = camera.WorldToScreen(wall.GetStartPoint());
ScreenPoint end = camera.WorldToScreen(wall.GetEndPoint());
// ... вычисление направления в экранных координатах
float offset = m_wallHalfWidthPx; // ОШИБКА: фиксированные пиксели
ScreenPoint s1(start.X + perpX * offset, ...);

// ДОЛЖНО БЫТЬ (правильно):
// 1. Получить углы в МИРОВЫХ координатах
WorldPoint p1, p2, p3, p4;
wall.GetCornerPoints(p1, p2, p3, p4);

// 2. Преобразовать в экранные
ScreenPoint s1 = camera.WorldToScreen(p1);
ScreenPoint s2 = camera.WorldToScreen(p2);
ScreenPoint s3 = camera.WorldToScreen(p3);
ScreenPoint s4 = camera.WorldToScreen(p4);
```

**Критерии завершения:**
- [x] DrawWall использует Wall::GetCornerPoints()
- [x] Все 4 угла преобразуются из мировых в экранные координаты
- [x] Толщина стен берется из m_thickness (в мм)
- [x] Код компилируется без ошибок
- [ ] Визуальная проверка: стены имеют корректную толщину

**Статус:** ? ЗАВЕРШЕНО (ожидает визуального тестирования)

---

### ? ЭТАП 3: Проверка DrawPreview
**Цель:** Убедиться, что preview стен тоже использует мировые координаты

**Задачи:**
- [x] 3.1. Проверить метод DrawPreview в WallRenderer
- [x] 3.2. Применить те же изменения что и в DrawWall
- [x] 3.3. Убедиться что preview стены выглядит идентично реальной

**Примечание:** DrawPreview создает временный объект Wall и вызывает DrawWall, 
поэтому изменения автоматически применились и к preview.

**Критерии завершения:**
- [x] DrawPreview использует тот же подход что и DrawWall
- [ ] Preview стена имеет корректную толщину
- [ ] При рисовании стены её preview не "прыгает"

**Статус:** ? ЗАВЕРШЕНО (ожидает визуального тестирования)

---

### ? ЭТАП 4: Тестирование разных уровней зума
**Цель:** Проверить что стены остаются статичными при любом зуме

**Задачи:**
- [ ] 4.1. Создать тестовую стену толщиной 150мм
- [ ] 4.2. Протестировать зум 1:20 (zoom = 1.25)
- [ ] 4.3. Протестировать зум 1:50 (zoom = 0.5)
- [ ] 4.4. Протестировать зум 1:100 (zoom = 0.25)
- [ ] 4.5. Протестировать зум 1:200 (zoom = 0.125)
- [ ] 4.6. Протестировать зум 1:500 (zoom = 0.05)
- [ ] 4.7. Протестировать экстремальные значения (minZoom=0.01, maxZoom=10.0)

**Критерии завершения:**
- [ ] При любом зуме визуальная толщина стены корректна
- [ ] Стена "150мм" выглядит реалистично на всех масштабах
- [ ] Геометрия стены правильно масштабируется
- [ ] Обводка (stroke) остается видимой и четкой

**Статус:** ? ОЖИДАЕТ

---

### ? ЭТАП 5: Проверка совместимости с другими компонентами
**Цель:** Убедиться что изменения не сломали другие системы

**Задачи:**
- [ ] 5.1. Проверить WallSnapSystem - привязка к стенам
- [ ] 5.2. Проверить WallJoinSystem - соединения стен
- [ ] 5.3. Проверить WallAttachmentSystem - выравнивание стен
- [ ] 5.4. Проверить OpeningRenderer - двери и окна на стенах
- [ ] 5.5. Проверить DimensionRenderer - размеры стен
- [ ] 5.6. Проверить RoomDetector - определение помещений
- [ ] 5.7. Проверить сохранение/загрузку проектов

**Критерии завершения:**
- [ ] Все системы работают корректно
- [ ] HitTest стен работает правильно
- [ ] Привязка к стенам работает
- [ ] Размеры отображаются корректно
- [ ] Двери и окна размещаются правильно

**Статус:** ? ОЖИДАЕТ

---

### ? ЭТАП 6: Оптимизация производительности
**Цель:** Убедиться что изменения не замедлили рендеринг

**Задачи:**
- [ ] 6.1. Профилировать рендеринг 100 стен
- [ ] 6.2. Профилировать рендеринг 1000 стен
- [ ] 6.3. Сравнить с предыдущей версией
- [ ] 6.4. Оптимизировать при необходимости

**Критерии завершения:**
- [ ] Рендеринг работает не медленнее предыдущей версии
- [ ] FPS остается стабильным при большом количестве стен
- [ ] Нет утечек памяти

**Статус:** ? ОЖИДАЕТ

---

### ? ЭТАП 7: Документация и финализация
**Цель:** Задокументировать изменения

**Задачи:**
- [ ] 7.1. Обновить комментарии в WallRenderer.h
- [ ] 7.2. Добавить пример использования в документацию
- [ ] 7.3. Обновить PROGRESS.md
- [ ] 7.4. Создать commit с описанием изменений

**Критерии завершения:**
- [ ] Код хорошо прокомментирован
- [ ] Документация обновлена
- [ ] Изменения зафиксированы в git

**Статус:** ? ОЖИДАЕТ

---

## ТЕКУЩИЙ СТАТУС
- **Активный этап:** ЭТАП 4 - Тестирование разных уровней зума
- **Прогресс:** 3/7 этапов завершено (43%)
- **Код:** ? Реализован и скомпилирован успешно
- **Сборка:** ? Проект собирается без ошибок
- **Следующий шаг:** Визуальное тестирование на разных масштабах

### ?? ГОТОВО К ТЕСТИРОВАНИЮ!

Все изменения реализованы и код успешно скомпилирован. 
Теперь необходимо запустить приложение и выполнить визуальное тестирование.

**Быстрая проверка (1 минута):**
1. Запустить приложение
2. Создать стену 150мм и стену 380мм
3. Изменить масштаб колесом мыши
4. Убедиться что стены масштабируются пропорционально

**Полное тестирование (10 минут):**
Следовать инструкциям в файле `docs/WALL_RENDERING_TEST_GUIDE.md`

## РЕАЛИЗОВАННЫЕ ИЗМЕНЕНИЯ

### WallRenderer.h - метод DrawWall()
**До:**
```cpp
// Преобразуем концы стены в экранные координаты
ScreenPoint start = camera.WorldToScreen(wall.GetStartPoint());
ScreenPoint end = camera.WorldToScreen(wall.GetEndPoint());
// Вычисляем направление в экранных координатах
float dx = end.X - start.X;
float dy = end.Y - start.Y;
float len = std::sqrt(dx * dx + dy * dy);
// ...
float offset = m_wallHalfWidthPx; // ПРОБЛЕМА: 6 пикселей
ScreenPoint s1(start.X + perpX * offset, start.Y + perpY * offset);
```

**После:**
```cpp
// 1. Получаем углы стены в МИРОВЫХ координатах (мм)
WorldPoint p1, p2, p3, p4;
wall.GetCornerPoints(p1, p2, p3, p4);

// 2. Преобразуем все 4 угла в экранные координаты
ScreenPoint s1 = camera.WorldToScreen(p1);
ScreenPoint s2 = camera.WorldToScreen(p2);
ScreenPoint s3 = camera.WorldToScreen(p3);
ScreenPoint s4 = camera.WorldToScreen(p4);
```

### Удаленные константы:
- ? `m_wallHalfWidthPx = 6.0f` - больше не используется

### Измененные константы:
- ? `m_wallStrokeWidthPx = 2.0f` (было 4.0f) - более тонкая обводка
- ? `m_selectedStrokeWidthPx = 3.0f` (было 5.0f) - пропорционально уменьшена

## ОЖИДАЕМЫЕ РЕЗУЛЬТАТЫ ТЕСТИРОВАНИЯ

При запуске приложения вы должны увидеть:

1. **Стены с реальными размерами:**
   - Стена 150мм должна выглядеть тоньше стены 380мм
   - Толщина соответствует реальным размерам в мировых координатах

2. **Стабильность при зуме:**
   - При масштабе 1:50 - стена 150мм видна четко
   - При масштабе 1:100 - стена 150мм видна, но тоньше
   - При масштабе 1:20 - стена 150мм толще на экране
   - ГЛАВНОЕ: геометрические пропорции сохраняются!

3. **Сравнение с AutoCAD/nanoCAD:**
   - При зуме меняется масштаб всего чертежа
   - НО пропорции между элементами сохраняются
   - Тонкие стены остаются тоньше толстых на любом масштабе

## ТЕХНИЧЕСКИЕ ДЕТАЛИ

### Используемые классы и методы:
- `Wall::GetCornerPoints()` - возвращает 4 угла стены в мировых координатах
- `Wall::GetThickness()` - возвращает толщину в мм
- `Camera::WorldToScreen()` - преобразует мировые координаты в экранные
- `Camera::GetZoom()` - текущий уровень зума (пиксели на мм)

### Ключевые изменения:
1. **WallRenderer.h:** полная переработка DrawWall и DrawPreview
2. **Удаление:** константа m_wallHalfWidthPx
3. **Сохранение:** константы для толщины обводки (stroke width)

### Ожидаемый результат:
? Стены имеют реальную толщину в мм (например, 150мм, 200мм, 380мм)
? При зуме геометрия стен правильно масштабируется
? Визуальная толщина стен выглядит реалистично на любом масштабе
? Обводка стен остается четкой и видимой (фиксированная в пикселях)
? Система работает как в AutoCAD/nanoCAD
